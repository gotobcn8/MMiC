import numpy as np

def MixUp(dataset, mix_rate = 1.0, alpha = 0.75, beta = 0.75):
    '''
    dataset which is need to be augmented, mix_rate is rate of joining mix data, alpha is the distribution parameter. 
    MixUp augmentation is used to solve problem of pseudo label and potential labels with low quality.
    Step 1: Randomly shuffle the dataset;
    Step 2: Generate new data by old dataset and shuffle dataset by X_mix = gamma * X + ( 1 - gamma ) * X_random
    finally we got the results.
    '''
    X,y = dataset['x'],dataset['y']
    size = int(X.shape[0] * mix_rate)
    single_d_gamma = np.random.beta(a = alpha, b = beta, size = size)
    X_selected_data = X[:size]
    y_selected_data = y[:size]
    random_data_index = np.random.choice(a = X.shape[0],size = size)
    X_random = X[random_data_index]
    y_random = y[random_data_index]
    gamma = expand_weight(single_d_gamma)
    X_mix_data = X_selected_data * gamma  + X_random * (1 - gamma)
    y_mix_data = y_selected_data * single_d_gamma  + y_random * (1 - single_d_gamma)

    return np.concatenate((X,X_mix_data),axis=0),np.round(np.concatenate((y,y_mix_data),axis=0)).astype(int)

def expand_weight(weights):
    return weights[:,np.newaxis,np.newaxis,np.newaxis]

def ReMixup(dataset, mix_rate = 1.0,alpha = 0.75,beta = 0.75,k_majority = 2.0,tao = 0.5):
    '''
    Improvements for Mixup
    define k-majority, gamma generated by beta distribution
    '''
    X,y = dataset['x'],dataset['y']
    unique_class,counts = np.unique(
        y,return_counts = True
    )
    y_maps = dict()
    for class_k,samples in zip(unique_class,counts):
        y_maps[class_k] = samples
    size = int(X.shape[0] * mix_rate)
    single_d_gamma = np.random.beta(a = alpha, b = beta, size = size)
    X_selected_data = X[:size]
    y_selected_data = y[:size]
    random_data_index = np.random.choice(a = X.shape[0],size = size)
    X_random = X[random_data_index]
    y_random = y[random_data_index]
    X_gamma = expand_weight(single_d_gamma)
    y_1d_gamma = []
    for ys,yr,sgamma in zip(y_selected_data,y_random,single_d_gamma):
        proportion = y_maps[ys] / y_maps[yr]
        if proportion >= k_majority and sgamma < tao:
            y_1d_gamma.append(0)
        elif proportion <= 1/k_majority and 1-sgamma < tao:
            y_1d_gamma.append(1)
        else:
            y_1d_gamma.append(sgamma)
    y_1d_gamma = np.array(y_1d_gamma)
    X_mix_data = X_selected_data * X_gamma  + X_random * (1 - X_gamma)
    y_mix_data = y_selected_data * y_1d_gamma  + y_random * (1 - y_1d_gamma)
    return np.concatenate((X,X_mix_data),axis=0),np.round(np.concatenate((y,y_mix_data),axis=0)).astype(int)
